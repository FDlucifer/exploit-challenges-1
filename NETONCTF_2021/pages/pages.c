#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <assert.h>
#include <unistd.h>
#include <time.h>

#define PAGE_SIZE 256

typedef struct page_table_entry {
	void* next;
	uint64_t l1;
	time_t last_access;
	uint8_t freed;
	char* phys_addr;
} PTE;

typedef struct page_table {
	void* next;
	uint64_t l0;
	PTE* pte;
} PT;

PT* pt_head;

void gc()
{
	time_t current_time = time(NULL);

	if (!pt_head)
		return;

	/* Just free a page if it's not the last of the page table, else, 
	 * it's probably going to be used sooner or later. Same with page entries.
	 */
	for (PT *pt = pt_head; pt->next != NULL; pt = pt->next) {
		for (PTE *pte = pt->pte; pte->next != NULL; pte = pte->next) {
			if ((uint32_t)(current_time - pte->last_access) > 10 && !pte->freed) {
				/* free the damn thing */
				free(pte->phys_addr);
				pte->freed = 1;
			}
		}
	}
}

uint64_t _resolve_vaddr(uint64_t vaddr)
{
	uint16_t l0;
	uint16_t l1;
	uint8_t off;
	PT* pt;
	PTE *pte;

	/* Calculate offsets and levels*/
	l0 = (vaddr >> 20); /* 0xdeadbeef -> 0xdea */
	l1 = (vaddr >> 8) & 0xfff; /* 0xdeadbeef -> 0xdbe */
	off = vaddr & 0xff; /* 0xdeadbeef -> 0xef */

	if (!pt_head) {
		/* Then for sure this is a new address */
		pt_head = (PT *)calloc(1, sizeof(PT));
		pt = pt_head;
		pt->l0 = l0;
		pt->pte = (PTE *)calloc(1, sizeof(PTE));
		pt->pte->l1 = l1;
		pt->pte->phys_addr = (char *)malloc(PAGE_SIZE + 1);
		pt->pte->last_access = time(NULL); /* For Garbage Collector */
		pte = pt->pte;

	}
	/* Walk the page table */
	else {
		for (pt = pt_head; pt->next != NULL; pt = pt->next) {
			if (pt->l0 == l0)
				break;
		}
		if (pt->l0 != l0) {
			/* There's no page table for this address, create it */
			pt->next = (PT *)calloc(1, sizeof(PT));
			pt = pt->next;
			pt->l0 = l0;
			pt->pte = (PTE *)calloc(1, sizeof(PTE));
			pt->pte->l1 = l1;
			pt->pte->phys_addr = (char *)malloc(PAGE_SIZE + 1);
			pt->pte->last_access = time(NULL); /* For Garbage Collector */
			pte = pt->pte;
		} else {
			/* Walk the page entries of the page table */
			for (pte = pt->pte; pte->next != NULL; pte = pte->next) {
				if (pte->l1 == l1)
					break;
			}
			if (pte->l1 != l1) {
				/* There's no page table entry for this address, create it */
				pte->next = calloc(1, sizeof(PTE));
				pte = pte->next;
				pte->l1 = l1;
				pte->phys_addr = (char *)malloc(PAGE_SIZE + 1);
				pte->last_access = time(NULL); /* For Garbage Collector */
			}
		}
	}

	/* Call garbage collector and get rid of unused pages */
	gc();

	return (uint64_t)pte->phys_addr + (uint64_t)off;

}

void write_to_address()
{
	uint64_t vaddr;
	uint64_t physical_address;
	uint16_t len;
	printf("address > ");
	fflush(stdout);

	scanf("%lx", &vaddr);

	physical_address = _resolve_vaddr(vaddr);

	printf("data > ");
	fflush(stdout);

	len = read(0, (char *)physical_address, PAGE_SIZE - (vaddr & 0xff) - 1);
	*((char *)physical_address + len) = '\0';
}

void read_from_address()
{
	uint64_t vaddr;
	uint64_t physical_address;
	uint32_t length;
	char data[PAGE_SIZE];

	printf("address > ");
	fflush(stdout);

	scanf("%lx", &vaddr);

	physical_address = _resolve_vaddr(vaddr);

	printf("length > ");
	fflush(stdout);

	scanf("%d", &length);

	/* Sanity check */
	assert(length < PAGE_SIZE-1);

	/* Initialize destination and copy data to it */
	memset(data, 0, sizeof(data));
	memcpy(data, (char *)physical_address, length);

	printf("0x%lx ==> %s\n", vaddr, data);
}

void welcome()
{
	puts("Welcome to the Operating systems lab!");
}

void menu()
{
	puts("1. Write to address");
	puts("2. Read from address");
	puts("3. Exit");
	printf("your choice > ");
	fflush(stdout);
}

int main(int argc, char **argv)
{
	int choice;
	
	welcome();
	while (1) {
		menu();
		scanf("%d", &choice);
		switch(choice) {
			case 1:
				write_to_address();
				break;
			case 2:
				read_from_address();
				break;
			default:
				puts("Bye!");
				exit(0);
		}
	}

	return 0;
}
